- **理论依据**

  - MMU
    - 虚拟内存
    - MMU工作过程
    - TLB
    - 概念说明

  

## 理论依据

## MMU

**MMU(Memory Management Unit)**即内存管理单元，是一种负责处理CPU内存访问请求的CPU可选硬件，在现代 CPU 中广泛使用。MMU有多种功能：对内存地址的访问进行控制，对代码段只读权限控制，对多线程的栈内存之间的空洞页进行隔离以防止栈溢出后改写其他线程的栈内存，不同进程之间的地址隔离(**内存保护**)等等。但MMU主要负责的还是虚拟地址与物理地址的转换(**地址映射**)，提供硬件机制的内存访问授权。

为了高效简便地解决应用程序太大以至于内存容纳不下该程序的问题，虚拟存储器诞生了，同时，为了合理地控制虚拟存储单元和物理存储单元的映射，人们创造了MMU以便进行有效的管理。



#### 虚拟内存

**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存，而实际上物理内存通常被分隔成多个内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术使得大型程序的编写变得更容易，对真正的物理内存的使用也更有效率。

对虚拟内存的定义是基于对地址空间的重定义的，即把地址空间定义为“连续的虚拟内存地址”，以借此“欺骗”程序，使它们以为自己正在使用一大块的“连续”地址。



#### MMU工作过程

大多数使用虚拟存储器的系统都使用一种称为**分页(paging)**的技术。虚拟地址空间划分成称为**页(page)**的单位，而相应的物理地址空间也被进行划分，单位是**页框(frame)**。页和页框的大小必须相同。

每一页首先有一个用来标识它的页号，且有两个重要信息量，分别是**Present位**和**页框索引(Frame Index)**，位P(1有效)指出该页是否存在有效的映射，而页框索引指明该页向哪个物理页框进行映射。对于该页中的每一个虚拟地址，都被截断为两个部分，高位部分是**页号索引(page Index)**，低位则是相对该页首地址的**偏移量(offset)**。

下面利用伪代码进行举例说明：

>  MOVE REG, A0

该指令表示将地址A0处的内容传递进寄存器REG，MMU有以下几种情况：

1. MMU接收地址A0，检测位p，若Present = 1，说明虚拟地址A0所在页存在物理映射，设该页首地址为A1，MMU通过页框索引找到相应页框的首地址A2，保留A0的偏移量并修改页号索引为页框索引，即可达到(A0 - A1) + A2的效果，最终映射到正确的物理地址。
2. 若Present = 1，说明虚拟地址A0所在页无有效映射，于是通知CPU发生一个**缺页故障(page fault)**。操作系统将会介入，从有限的物理页框中找到1个当前很少被使用的页框并把该页框的内容写入外围存储器(page copy)，随后需要修改新、旧两页的页框索引和位p，把新页映射到刚才释放的页框中，结束后，重新执行产生故障的指令。

#### TLB

**TLB(Translation Lookaside Buffer)**为CPU的一种高速缓存，用于存放将虚拟地址映射至物理地址的映射转换表的**遍历结果**，这个结构是为了改进内存管理单元从虚拟地址到物理地址的转译速度而设计的。

当存储器中的转换表被改变或选中了不同的转换表，MMU就会刷新TLB。当访问存储器时，MMU 先查找 TLB ，如果命中，则按上述流程执行，如果没有命中，则会再去存储器中遍历转换表，寻找对应的映射(Table Walk)，并将利用遍历结果更新TLB。



#### 概念说明

1. MPU(Memory Protection Unit)主要用于内存保护(protect/restrict memory to tasks)，但是不具备地址映射能力(remapping the address space)，可以将MMU理解为MPU的升级版。

2. 只有存在MMU时，才有进程这个概念，否则只有线程这个概念。比如没有MMU的单片机中(即使有操作系统，比如FreeRTOS)，就不存在进程这个说法，只有线程或着叫做task(任务)。因为没有MMU就没办法实现内存空间的隔离。

3. Cotex-M系列(例如STM32)没有MMU，但是Cotex-A系列有。