## RUST

rust是一种系统级编程语言，与其他语言相比，在安全方面有以下优越性：

1. 内存安全性：rust通过使用所有权（ownership）、租借（borrowing）和生命周期（lifetime）的概念来管理内存。这些概念确保了在编译时就避免了常见的内存错误，例如空指针、野指针、缓冲区溢出和数据竞争等。
2. 防止空指针引用：在rust中，空指针是不存在的，因为所有指针都必须指向有效的内存地址。这使得rust程序更加健壮，减少了由于空指针引用而导致的崩溃问题。
3. 数据竞争检测：rust在编译时执行数据竞争检测，确保多个线程或并发任务之间的共享数据访问不会导致不可预期的行为，可以避免许多常见的内存错误和多线程问题。
4. 防止缓冲区溢出：rust的标准库提供了一系列安全的api，可以帮助开发人员编写更加安全的代码，包括字符串处理和文件i/o等功能。
5. 函数式编程特性：rust的函数式编程特性能够帮助开发人员编写更加简洁和安全的代码，例如避免使用可变状态、将函数作为一等公民等等。
6. 性能：Rust 能够在损失较少性能的情况下提供高度的安全性， 具有与 C 和 C++ 相当的性能，可以编写高性能的系统级代码。Rust 的内存管理机制使其比其他语言更适合编写高性能的并发程序。

#### 概念分析

1. **所有权**：相比C/C++这样手动管理内存的语言，和JAVA这种在自动回收内存资源的同时降低运行效率的语言，Rust通过所有权可以在编译阶段就能有效分析内存资源有效性，在牺牲较少性能的情况下提升管理效率。

2. **所有权规则**：

   1. Rust 中的每个值都有一个变量，称为其所有者；
   2. 一次只能有一个所有者；
   3. 当所有者不在程序运行范围时，该值将被删除。

   

   对于基本数据类型(int、struct等)的栈内存，超出作用域后的自动释放和其他语言差别不大；

   但对于Rust中非基本数据类型的数据(String等)，交互发生在堆中，Rust对堆内存一视同仁，也会在超出作用域后自动释放。

   如`let s1 = String::from("hello");` 此时有以下几种保护内存的方式：

   1. 某段内存只能被最后的变量名所有，前面声明过的变量都作废，以`let s2 = s1;` 为例，该语句之后s1失效，所有权转交给s2，可以防止多次释放。

   2. **租借(borrowing)**: `let s2 = &s1;`

      通过引用的方式s2租借了值的所有权，在s1所有权改变时s2将无法继续租借；除非同时s1可变且s2为可变引用，否则s2只有使用权，而无法修改。

   3. 可变引用不允许多重引用，防止了并发状态下数据访问碰撞。

   4. 编译器会发现悬垂引用并进行报错。

