
## 技术依据：Rust 重写 FreeRTOS 可行性分析
Rust 是一个系统级编程语言，其理念为 “零开销抽象”，被设计为保证内存和线程安全，防止段错误产生。Rust 有线程安全的特点，强调安全性、内存控制与并发。同时，Rust 杜绝了空指针与悬垂指针，提高了程序的安全性。针对 FreeRTOS 现有的一些问题，如可靠性问题、实时性问题等，Rust 的这些特点即可解决。

#### Rust 保证可靠性
FreeRTOS 在设计上注重轻量化和效率，但在一些特殊场景下可能存在可靠性问题，如内存泄露、死锁、竞争条件等，这些需要开发者细致的验证与测试以避免，而 Rust 因其安全性特点，可以很好地解决这些问题。

##### 内存泄露问题
内存泄漏指在程序中使用动态内存分配时，没有正确地释放已经不再使用的内存空间，导致系统中存在一些被分配但无法被访问的内存块，从而浪费了系统的内存资源。这些内存块可能会导致程序运行过程中出现异常行为，例如程序崩溃、性能下降等。FreeRTOS 一般用于嵌入式系统，目前其应用场景一般内存空间并不大。同时，它要求良好的实时性，而系统性能不足时，可能会造成任务响应延迟、丢失等问题。故改进 FreeRTOS 应关注内存泄露的问题，而 Rust 可以很好地解决这个问题。
Rust 语言采用了所有权（ownership）和借用（borrowing）机制，通过编译时检查和运行时检查相结合的方式来保证内存安全，避免了内存泄漏和空指针等问题。
* 所有权机制规定了每一个值在任意时刻都只有一个所有者，当所有者离开作用域时，其所拥有的资源将会被自动释放。这样就避免了程序中存在无法被回收的内存空间的情况。
* 借用机制则允许代码在不拥有某个值的情况下使用它，这使得代码可以在不破坏所有权的前提下访问资源

##### 线程安全问题
Rust 语言可以通过多种机制来保证线程安全：
* 所有权和借用机制：Rust 的所有权和借用机制可以保证同一时刻只有一个线程拥有对某个资源的访问权，其他线程必须等待该线程完成后才能访问，从而避免了竞争条件的出现。如以下一段程序：
  ```rust
  let mut s = String::from("hello");

  let r1 = &mut s;
  let r2 = &mut s;
  
  println!("{}, {}", r1, r2);
  ```
  无法通过编译，因为 Rust 不允许在一个值被可变引用时再次被任何引用，以此来避免数据访问碰撞
* Sync 和 Send trait：Rust 语言提供了 Sync 和 Send trait，分别用于标记类型是否可以在多线程之间共享和传递。只有实现了 Sync 和 Send trait 的类型才能够被安全地用于多线程并发。
* Mutex 和 RwLock：Rust 标准库提供了 Mutex 和 RwLock 两个互斥锁类型，分别用于保护共享资源的访问。使用这两种锁可以避免多线程之间对同一个资源进行竞争的情况，保证线程安全。
  ```rust
  
  use std::sync::{Arc, Mutex};
  use std::thread;
  
  fn main() {
        // Arc 表示多个线程之间共享的一个可变的数据，Mutex 表示线程安全的互斥锁
        let data = Arc::new(Mutex::new(0)); 
  
        let mut handles = vec![];
  
        for i in 0..10 {
            let data = data.clone();
            let handle = thread::spawn(move || {
                let mut data = data.lock().unwrap(); // 获取互斥锁
                *data += 1; // 对共享数据进行操作
            });
            handles.push(handle);
        }
    
        for handle in handles {
            handle.join().unwrap(); // 等待线程完成
        }
    
        println!("Result: {}", *data.lock().unwrap()); // 获取  互斥锁，并输出结果
  }
  ```
  data 是一个使用 Arc 和 Mutex 包装起来的可变数据，表示多个线程之间共享的一个数据。在每个线程中，通过调用 data.lock().unwrap() 方法获取互斥锁，然后对共享数据进行操作。使用 Arc 和 Mutex 可以保证多个线程之间对同一个数据的访问是安全的。
* Atomic：Rust 还提供了 Atomic 类型，可以用于对某个变量进行原子性的操作，避免了多个线程对同一个变量进行并发修改的问题

这些可以让我们编写出正确的代码从而保证线程安全

##### 内存安全问题
FreeRTOS 在开发过程中也会有一些内存安全问题，需要开发者仔细避免，而用 Rust 可以减少许多这方面的考虑
**(1) 由空指针引发的问题**
空指针便利了许多程序，但也常造成一些错误、漏洞和系统崩溃，如对空指针解引用。而 Rust 并不支持空值，而是采取用 Option 枚举代替空值
```rust
enum Option<T> {
	Some(T),
	None,
}
```
`Option<T>` 与T并不是相同的类型，所以编译器不会允许我们像使用普通值那样去直接使用 `Option<T>` 的值。为了使用 `Option<T>` 中可能存在的T，我们必须将它转换为T。一般而言，这能帮助我们避免使用空值时最常见的一个问题：假设某个值存在，实际上却为空。这一设计十分有效地限制了空值泛滥，从而增加了 Rust 代码的安全性。 
**(2) 其他**
Rust 因其语言特性，还可以解决许多其他的内存安全问题
1. 使用未初始化内存	
   Rust 编译器禁止变量读取未赋值变量，在使用之前需要绑定、引用等
2. 出现悬垂指针	
   Rust 通过编译器检查与生命周期标识，可以有效避免悬垂指针的出现
3. 缓冲区溢出	
   Rust 通过编译器检查，会拒绝超越缓冲区边界的数据访问
4. 非法释放内存	
   对于释放未分配的指针或重复释放指针的问题，Rust 限制唯一的所有者才有权释放内存

这些都有效避免了许多内存安全问题的出现

#### Rust 的灵活性
##### 不安全代码快
在重写过程中，难免需要对硬件进行直接的操控，而因底层计算机硬件固有的不安全性，如果 Rust 不允许进行不安全的操作，那么某些底层任务可能根本就完成不了。因此可能会有经确认安全，但编译器不通过的代码。而 Rust 支持不安全代码块，这将使我们代码的编写更加方便。
使用关键字 `unsafe` 标记代码块后，便可以在被标记地代码块中使用不安全代码，以此成功通过编译。
```rust
unsafe fn dangerous() -> i32 {
  let mut num = 5;
  let r = &num as *const i32;
  return *r
}
dangerous(); // 报错，不允许unsafe块外部调用不安全函数

// 在unsafe块中调用
unsafe {
  let num = dangerous();
  println!("{}", num); // 5
}
```
##### 引用外部代码
原本的FreeRTOS使用 c 语言等编写而成，在用 Rust 重写时，可能会用到其他语言，即调用外部代码。
Rust 专门提供了 `extern` 关键字来简化创建和使用外部函数接口（Foreign Function Interface，FFI）的过程。FFI是编程语言定义函数的一种方式，它允许其他（外部的）编程语言来调用这些函数，如：
```rust
// 声明外部外部函数签名
extern "C" {
  fn abs(input: i32) -> i32;
}

// 需要在unsafe模块中调用
unsafe {
  abs(-10);
}

```
想要调用的外部函数和签名列在 `extern "C"` 块中，即可在之后的代码中用 `unsafe` 模块调用。
